# -*- coding: utf-8 -*-
"""Local Alignment with Affine Gap Penalty.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1A9KvcqZZ_P0ukBCpniGHGGQCt9Dx73re
"""

import os
os.chdir('C:/Users/mjmah/OneDrive/Desktop/everything/Main/term7/bio/HWs/HW1/q10')
# MJ Maheronnaghsh
BLOSUM62 = [
	[  4,   0,  -2,  -1,  -2,   0,  -2,  -1,  -1,  -1,  -1,  -2,  -1,  -1,  -1,   1,   0,   0,  -3,  -2],
	[  0,   9,  -3,  -4,  -2,  -3,  -3,  -1,  -3,  -1,  -1,  -3,  -3,  -3,  -3,  -1,  -1,  -1,  -2,  -2],
	[ -2,  -3,   6,   2,  -3,  -1,  -1,  -3,  -1,  -4,  -3,   1,  -1,   0,  -2,   0,  -1,  -3,  -4,  -3],
	[ -1,  -4,   2,   5,  -3,  -2,   0,  -3,   1,  -3,  -2,   0,  -1,   2,   0,   0,  -1,  -2,  -3,  -2],
	[ -2,  -2,  -3,  -3,   6,  -3,  -1,   0,  -3,   0,   0,  -3,  -4,  -3,  -3,  -2,  -2,  -1,   1,   3],
	[  0,  -3,  -1,  -2,  -3,   6,  -2,  -4,  -2,  -4,  -3,   0,  -2,  -2,  -2,   0,  -2,  -3,  -2,  -3],
	[ -2,  -3,  -1,   0,  -1,  -2,   8,  -3,  -1,  -3,  -2,   1,  -2,   0,   0,  -1,  -2,  -3,  -2,   2],
	[ -1,  -1,  -3,  -3,   0,  -4,  -3,   4,  -3,   2,   1,  -3,  -3,  -3,  -3,  -2,  -1,   3,  -3,  -1],
	[ -1,  -3,  -1,   1,  -3,  -2,  -1,  -3,   5,  -2,  -1,   0,  -1,   1,   2,   0,  -1,  -2,  -3,  -2],
	[ -1,  -1,  -4,  -3,   0,  -4,  -3,   2,  -2,   4,   2,  -3,  -3,  -2,  -2,  -2,  -1,   1,  -2,  -1],
	[ -1,  -1,  -3,  -2,   0,  -3,  -2,   1,  -1,   2,   5,  -2,  -2,   0,  -1,  -1,  -1,   1,  -1,  -1],
	[ -2,  -3,   1,   0,  -3,   0,   1,  -3,   0,  -3,  -2,   6,  -2,   0,   0,   1,   0,  -3,  -4,  -2],
	[ -1,  -3,  -1,  -1,  -4,  -2,  -2,  -3,  -1,  -3,  -2,  -2,   7,  -1,  -2,  -1,  -1,  -2,  -4,  -3],
	[ -1,  -3,   0,   2,  -3,  -2,   0,  -3,   1,  -2,   0,   0,  -1,   5,   1,   0,  -1,  -2,  -2,  -1],
	[ -1,  -3,  -2,   0,  -3,  -2,   0,  -3,   2,  -2,  -1,   0,  -2,   1,   5,  -1,  -1,  -3,  -3,  -2],
	[  1,  -1,   0,   0,  -2,   0,  -1,  -2,   0,  -2,  -1,   1,  -1,   0,  -1,   4,   1,  -2,  -3,  -2],
	[  0,  -1,  -1,  -1,  -2,  -2,  -2,  -1,  -1,  -1,  -1,   0,  -1,  -1,  -1,   1,   5,   0,  -2,  -2],
	[  0,  -1,  -3,  -2,  -1,  -3,  -3,   3,  -2,   1,   1,  -3,  -2,  -2,  -3,  -2,   0,   4,  -3,  -1],
	[ -3,  -2,  -4,  -3,   1,  -2,  -2,  -3,  -3,  -2,  -1,  -4,  -4,  -2,  -3,  -3,  -2,  -3,  11,   2],
	[ -2,  -2,  -3,  -2,   3,  -3,   2,  -1,  -2,  -1,  -1,  -2,  -3,  -1,  -2,  -2,  -2,  -1,   2,   7]
]
BLOSUM62_ENTRIES = ['A', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'Y']
BLOSUM62_MAP = dict(zip(BLOSUM62_ENTRIES, range(len(BLOSUM62_ENTRIES))))

class DNA:
  def __init__(self):
    self.string = ""
  def add_neucleotide(self, to_add):
    self.string += to_add

def scan():
  all_DNAs = []
  last_dna = None

  with open('rosalind_laff-6.txt', 'r') as file:
    for dna in file:
      dna = dna.strip()
      if dna.startswith('>'):
        last_dna = DNA()
        all_DNAs.append(last_dna)
      else:
        last_dna.add_neucleotide(dna)


  all_DNAs[0].string.replace('\n', '')
  all_DNAs[1].string.replace('\n', '')

  a = all_DNAs[0].string
  b = all_DNAs[1].string
  return a, b

def initialization():
  D = [[None for j in range(len(a)+1)] for i in range(len(b)+1)]
  P = [[None for j in range(len(a)+1)] for i in range(len(b)+1)]
  Q = [[None for j in range(len(a)+1)] for i in range(len(b)+1)]
  for i in range(len(b)+1):
    D[i][0] = 0
    Q[i][0] = -100000 # a big number
  for j in range(len(a)+1):
    D[0][j] = 0
    P[0][j] = -100000 # a big number
  P[0][0], Q[0][0] = 0, 0
  return D, P, Q

def find_bests(GAP_OPENING_PENALTY, GAP_EXTENTION_PENALTY, D, P, Q):
  best_val = -100000 # a big number
  best_i, best_j = None, None
  for i in range(1, len(b)+1):
    for j in range(1, len(a)+1):
      P[i][j] = max(D[i-1][j] + GAP_OPENING_PENALTY, P[i-1][j] + GAP_EXTENTION_PENALTY)
      Q[i][j] = max(D[i][j-1] + GAP_OPENING_PENALTY, Q[i][j-1] + GAP_EXTENTION_PENALTY)
      match_score = D[i-1][j-1] + BLOSUM62[BLOSUM62_MAP[a[j-1]]][BLOSUM62_MAP[b[i-1]]]
      D[i][j] = max(0, match_score, P[i][j], Q[i][j])
      if D[i][j] > best_val:
        best_val = D[i][j]
        best_i, best_j = i, j
  print(best_val)
  return best_i, best_j

def calc(a, b):
  GAP_OPENING_PENALTY = -11
  GAP_EXTENTION_PENALTY = -1

  D, P, Q = initialization()

  best_i, best_j = find_bests(GAP_OPENING_PENALTY, GAP_EXTENTION_PENALTY, D, P, Q)

  a_alig = []
  b_alig = []
  cur_i, cur_j = best_i, best_j

  while D[cur_i][cur_j] > 0:
      match_score = D[cur_i-1][cur_j-1] + BLOSUM62[BLOSUM62_MAP[a[cur_j-1]]][BLOSUM62_MAP[b[cur_i-1]]]
      if D[cur_i][cur_j] ==  match_score:
        a_alig.append(a[cur_j-1])
        b_alig.append(b[cur_i-1])
        cur_i -= 1
        cur_j -= 1
      elif D[cur_i][cur_j] == P[cur_i][cur_j]:
        cur_mat = 'P'
      elif D[cur_i][cur_j] == Q[cur_i][cur_j]:
        cur_mat = 'Q'
      else:
        raise Exception()

  return ''.join(a_alig[::-1]), ''.join(b_alig[::-1])

a, b = scan()
answer1, answer2 = calc(a, b)
print(answer1)
print(answer2)